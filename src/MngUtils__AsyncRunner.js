// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var $$Promise = require("@ryyppy/rescript-promise/lib/js/src/Promise.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

function make(tasks, parallel) {
  return {
          parallel: parallel,
          tasks: Belt_Array.mapWithIndex(tasks, (function (index, task) {
                  return [
                          index,
                          task
                        ];
                })),
          results: Belt_Array.map(tasks, (function (param) {
                  
                }))
        };
}

var $$Error = /* @__PURE__ */Caml_exceptions.create("MngUtils__AsyncRunner.Error");

function execute(task) {
  return $$Promise.$$catch(Curry._1(task, undefined).then(function (result) {
                  return Promise.resolve({
                              TAG: /* Ok */0,
                              _0: result
                            });
                }), (function (exn) {
                return Promise.resolve({
                            TAG: /* Err */1,
                            _0: exn
                          });
              }));
}

function executeTimeout(task, timeout) {
  return new Promise((function (resolve, param) {
                var timeoutId = {
                  contents: undefined
                };
                var alreadyTimeout = {
                  contents: false
                };
                var alreadyResolved = {
                  contents: false
                };
                $$Promise.$$catch(Curry._1(task, undefined).then(function (result) {
                          if (!alreadyTimeout.contents) {
                            var timerId = timeoutId.contents;
                            if (timerId !== undefined) {
                              clearTimeout(Caml_option.valFromOption(timerId));
                            }
                            alreadyResolved.contents = true;
                            resolve({
                                  TAG: /* Ok */0,
                                  _0: result
                                });
                          }
                          return Promise.resolve(undefined);
                        }), (function (exn) {
                        if (!alreadyTimeout.contents) {
                          var timeoutId$1 = timeoutId.contents;
                          if (timeoutId$1 !== undefined) {
                            clearTimeout(Caml_option.valFromOption(timeoutId$1));
                          }
                          alreadyResolved.contents = true;
                          resolve({
                                TAG: /* Err */1,
                                _0: exn
                              });
                        }
                        return Promise.resolve(undefined);
                      }));
                timeoutId.contents = Caml_option.some(setTimeout((function (param) {
                            alreadyTimeout.contents = true;
                            if (alreadyResolved.contents) {
                              return ;
                            } else {
                              return resolve({
                                          TAG: /* Err */1,
                                          _0: {
                                            RE_EXN_ID: $$Error,
                                            _1: "time out."
                                          }
                                        });
                            }
                          }), timeout));
                
              }));
}

function runWithPollTimeWithTimeout(runner, pollTime, timeout) {
  if (runner.tasks.length < runner.parallel) {
    return Promise.resolve({
                TAG: /* Err */1,
                _0: {
                  RE_EXN_ID: $$Error,
                  _1: "the count of tasks must bigger than parallel."
                }
              });
  } else {
    return new Promise((function (resolve, param) {
                  var wait = function (param) {
                    if (Belt_Array.some(runner.results, (function (item) {
                              return item === undefined;
                            }))) {
                      setTimeout((function (param) {
                              return wait(undefined);
                            }), pollTime);
                      return ;
                    } else {
                      return resolve({
                                  TAG: /* Ok */0,
                                  _0: Belt_Array.map(runner.results, (function (result) {
                                          return result;
                                        }))
                                });
                    }
                  };
                  var slot = {
                    contents: []
                  };
                  for(var _for = 0 ,_for_finish = runner.parallel; _for < _for_finish; ++_for){
                    slot.contents.push(undefined);
                  }
                  var tasks = runner.tasks.concat([]);
                  var runWithParallel = function (param) {
                    if (tasks.length === 0) {
                      setTimeout((function (param) {
                              Promise.all(Belt_Array.keepMap(slot.contents, (function (task) {
                                          return Belt_Option.map(task, (function (task) {
                                                        return Curry._1(task, undefined);
                                                      }));
                                        })));
                              
                            }), 0);
                      return ;
                    }
                    slot.contents = Belt_Array.mapWithIndex(slot.contents, (function (index, task) {
                            if (task !== undefined) {
                              return task;
                            }
                            var task$1 = tasks.shift();
                            return Belt_Option.map(task$1 === undefined ? undefined : Caml_option.some(task$1), (function (param, param$1) {
                                          var task = param[1];
                                          var taskIndex = param[0];
                                          if (timeout !== undefined) {
                                            return executeTimeout(task, timeout).then(function (result) {
                                                        return Promise.resolve([
                                                                    result,
                                                                    index,
                                                                    taskIndex
                                                                  ]);
                                                      });
                                          } else {
                                            return execute(task).then(function (result) {
                                                        return Promise.resolve([
                                                                    result,
                                                                    index,
                                                                    taskIndex
                                                                  ]);
                                                      });
                                          }
                                        }));
                          }));
                    var hasTask = Belt_Array.some(slot.contents, (function (task) {
                            return task !== undefined;
                          }));
                    if (hasTask) {
                      Promise.race(Belt_Array.keepMap(slot.contents, (function (task) {
                                    return Belt_Option.map(task, (function (task) {
                                                  return Curry._1(task, undefined);
                                                }));
                                  }))).then(function (result) {
                            Caml_array.set(runner.results, result[2], result[0]);
                            Caml_array.set(slot.contents, result[1], undefined);
                            setTimeout((function (param) {
                                    return runWithParallel(undefined);
                                  }), 0);
                            return Promise.resolve(undefined);
                          });
                      return ;
                    }
                    
                  };
                  runWithParallel(undefined);
                  return wait(undefined);
                }));
  }
}

function run(runner) {
  return runWithPollTimeWithTimeout(runner, 50, undefined);
}

function runWithTimeout(runner, timeout) {
  return runWithPollTimeWithTimeout(runner, 50, timeout);
}

exports.make = make;
exports.$$Error = $$Error;
exports.execute = execute;
exports.executeTimeout = executeTimeout;
exports.runWithPollTimeWithTimeout = runWithPollTimeWithTimeout;
exports.run = run;
exports.runWithTimeout = runWithTimeout;
/* No side effect */
